package model

import com.ftel.bigdata.db.slick.SlickTrait
import com.ftel.bigdata.db.slick.TableGeneric

import slick.jdbc.PostgresProfile.api._
import slick.lifted.ProvenShape
import slick.lifted.ProvenShape.proveShapeOf

/**
 * "id" int4 DEFAULT  NOT NULL,
 * "name" varchar(100) COLLATE "default" NOT NULL,
 * "num_of_domain" int4 NOT NULL,
 * "input" varchar(150) COLLATE "default" NOT NULL,
 * "description" text COLLATE "default" NOT NULL,
 */
case class Malware(id: Int, name: String, numberOfDomain: Int, input: String, description: String) {
  def this(name: String) = this(0, name, 0, "0", "0")
}

class MalwareTable(tag: Tag) extends TableGeneric[(String, Int, String, String)](tag, "malware") {
  // This is the primary key column:
  def id: Rep[Int] = column[Int]("id") //, O.PrimaryKey)
  def name: Rep[String] = column[String]("name")
  def numberOfDomain: Rep[Int] = column[Int]("num_of_domain")
  def input: Rep[String] = column[String]("input")
  def description: Rep[String] = column[String]("description")

  // Every table needs a * projection with the same type as the table's type parameter
  def * : ProvenShape[(String, Int, String, String)] = (name, numberOfDomain, input, description)
}

/**
 * companion for Malware
 */
object MalwareTable {

  /*
  val SQL_UPSET = """
      INSERT INTO malware (id, name, numberOfDomain, input, description)
      VALUES (?, ?, ?, ?, ?)
      ON CONFLICT (name)
      DO UPDATE
      SET views=EXCLUDED.views;"""
  */

//  private def prepareData = (db: Database, data: Seq[Malware]) => {
//    val malware: TableQuery[Malwares] = TableQuery[Malwares]
//    val res = data.map(x => (x.id, x.name, x.numberOfDomain, x.input, x.description))
//    val setupAction = DBIO.seq(malware ++= res)
//    val setupFuture: Future[Unit] = db.run(setupAction)
//    Await.result(setupFuture, Duration.Inf)
//  }

  /**
   * Bulk insert new row to table, if conflict will throw exception
   */
  def insert(db: SlickTrait, rows: List[Malware]) {
    val table: TableQuery[MalwareTable] = TableQuery[MalwareTable]
    db.insert[Malware, (String, Int, String, String)](
        rows,
        1000,
        table,
        (x: Malware) => (x.name, x.numberOfDomain, x.input, x.description))
  }
  
  /**
   * Bulk insert new row to table, if conflict will throw exception
   */
//  def insert2(db: SlickTrait, rows: List[String]) {
//    val table: TableQuery[MalwareTable] = TableQuery[MalwareTable]
//    db.insert[Malware, (String, Int, String, String)](
//        rows.map(x => new Malware(x)),
//        1000,
//        table,
//        (x: Malware) => (x.name, x.numberOfDomain, x.input, x.description))
//  }
  
  def getNameAndId(db: SlickTrait): Map[String, Int] = {
    val table: TableQuery[MalwareTable] = TableQuery[MalwareTable]
    db.getNameAndId(table)
  }

//  def insert(rows: List[Malware]) {
//    PostgresSlick.insert[Malware]("postgres_malware", rows, 1000, prepareData)
//  }

  /*
  /**
   * Bulk insert new row to table, if row exist will update views of row
   */
  def upset(rdd: RDD[Row]) {
    val SQL = """
      INSERT INTO paytv (customerid, day, hour, appname, views) 
      VALUES (?, ?, ?, ?, ?) 
      ON CONFLICT (customerid,day,hour,appname) 
      DO UPDATE 
      SET views=EXCLUDED.views;"""

    rdd.foreachPartition(rddPartition => {
      val action = SimpleDBIO[Array[Int]] { session =>
        val statement = session.connection.prepareStatement(SQL)
        rddPartition.map { x =>
          statement.setString(1, x.customerId)
          statement.setString(2, x.day)
          statement.setInt(3, x.hour)
          statement.setString(4, x.appName)
          statement.setInt(5, x.views)
          statement.addBatch()
        }
        statement.executeBatch()
      }
      val db = Database.forConfig("postgres")
      val result = db.run(action)
      Await.result(result, Duration.Inf)
    })
    */
}